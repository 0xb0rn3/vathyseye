#!/usr/bin/env bash

#############################################################################
# VathysEye 5.0 - Ultimate CLI File Manager with SSH/SFTP
# Author: 0xb0rn3 | 0xbv1
# Description: Lightning-fast file manager with SSH/SFTP and embedded C
#############################################################################

VERSION="5.0.0"
AUTHOR="0xb0rn3 | 0xbv1"

# Color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[0;37m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Configuration
VATHYS_DIR="${HOME}/.vathyseye"
VATHYS_BIN="${VATHYS_DIR}/bin"
VATHYS_CACHE="${VATHYS_DIR}/cache"
VATHYS_CONFIG="${VATHYS_DIR}/config"
SSH_SESSIONS="${VATHYS_DIR}/sessions"
C_HELPER="${VATHYS_BIN}/fileops"
C_TRANSFER="${VATHYS_BIN}/fasttransfer"
INDEX_DB="${VATHYS_CACHE}/file.index"

# SSH Session variables
SSH_HOST=""
SSH_USER=""
SSH_PORT="22"
SSH_CONNECTED=false

# Banner
show_banner() {
    clear
    cat << "EOF"
â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•    â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•  
 â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â•šâ•â•â•â•  â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
                                                                              
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  ğŸ”¥ ULTIMATE CLI FILE MANAGER 5.0 ğŸ”¥                            â”‚
        â”‚  âš¡ LOCAL â€¢ SSH â€¢ SFTP â€¢ ULTRA-FAST TRANSFERS âš¡                â”‚
        â”‚  Author: 0xb0rn3 | 0xbv1  â”‚  IG: theehiv3  â”‚  Version: 5.0     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EOF
}

# Initialize directories
init_vathys() {
    mkdir -p "${VATHYS_DIR}" "${VATHYS_BIN}" "${VATHYS_CACHE}" "${VATHYS_CONFIG}" "${SSH_SESSIONS}"
    
    # Check if C helpers exist, compile if needed
    if [[ ! -x "${C_HELPER}" ]]; then
        echo -e "${YELLOW}âš¡ Compiling performance helper...${RESET}"
        compile_c_helper
    fi
    
    if [[ ! -x "${C_TRANSFER}" ]]; then
        echo -e "${YELLOW}âš¡ Compiling ultra-fast transfer engine...${RESET}"
        compile_transfer_engine
    fi
}

# Enhanced C helper with optimized multi-threading
compile_c_helper() {
    local c_source="${VATHYS_BIN}/fileops.c"
    
    cat > "${c_source}" << 'CEOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fnmatch.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>

#define MAX_PATH 4096
#define MAX_RESULTS 100000
#define NUM_THREADS 16
#define QUEUE_SIZE 10000

typedef struct {
    char path[MAX_PATH];
    unsigned long size;
    time_t mtime;
    mode_t mode;
} FileInfo;

typedef struct {
    char paths[QUEUE_SIZE][MAX_PATH];
    int front;
    int rear;
    int count;
    pthread_mutex_t mutex;
    pthread_cond_t not_empty;
    pthread_cond_t not_full;
} PathQueue;

typedef struct {
    char *pattern;
    PathQueue *queue;
    FileInfo *results;
    int *result_count;
    pthread_mutex_t *result_mutex;
    int *active_threads;
    pthread_mutex_t *active_mutex;
} ThreadData;

PathQueue* queue_init() {
    PathQueue *q = malloc(sizeof(PathQueue));
    q->front = 0;
    q->rear = 0;
    q->count = 0;
    pthread_mutex_init(&q->mutex, NULL);
    pthread_cond_init(&q->not_empty, NULL);
    pthread_cond_init(&q->not_full, NULL);
    return q;
}

void queue_push(PathQueue *q, const char *path) {
    pthread_mutex_lock(&q->mutex);
    while (q->count >= QUEUE_SIZE) {
        pthread_cond_wait(&q->not_full, &q->mutex);
    }
    strncpy(q->paths[q->rear], path, MAX_PATH);
    q->rear = (q->rear + 1) % QUEUE_SIZE;
    q->count++;
    pthread_cond_signal(&q->not_empty);
    pthread_mutex_unlock(&q->mutex);
}

int queue_pop(PathQueue *q, char *path) {
    pthread_mutex_lock(&q->mutex);
    while (q->count == 0) {
        pthread_cond_wait(&q->not_empty, &q->mutex);
    }
    strncpy(path, q->paths[q->front], MAX_PATH);
    q->front = (q->front + 1) % QUEUE_SIZE;
    q->count--;
    pthread_cond_signal(&q->not_full);
    pthread_mutex_unlock(&q->mutex);
    return 1;
}

int queue_is_empty(PathQueue *q) {
    pthread_mutex_lock(&q->mutex);
    int empty = (q->count == 0);
    pthread_mutex_unlock(&q->mutex);
    return empty;
}

int matches_pattern(const char *filename, const char *pattern) {
    if (strcmp(pattern, "*") == 0) return 1;
    return fnmatch(pattern, filename, FNM_CASEFOLD) == 0 ||
           strcasestr(filename, pattern) != NULL;
}

void scan_directory(const char *dir_path, const char *pattern, 
                   PathQueue *queue, FileInfo *results, 
                   int *result_count, pthread_mutex_t *mutex) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;
    
    struct dirent *entry;
    struct stat st;
    char path[MAX_PATH];
    
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;
            
        snprintf(path, sizeof(path), "%s/%s", dir_path, entry->d_name);
        
        if (stat(path, &st) == 0) {
            if (S_ISREG(st.st_mode) && matches_pattern(entry->d_name, pattern)) {
                pthread_mutex_lock(mutex);
                if (*result_count < MAX_RESULTS) {
                    strncpy(results[*result_count].path, path, MAX_PATH);
                    results[*result_count].size = st.st_size;
                    results[*result_count].mtime = st.st_mtime;
                    results[*result_count].mode = st.st_mode;
                    (*result_count)++;
                }
                pthread_mutex_unlock(mutex);
            }
            
            if (S_ISDIR(st.st_mode)) {
                queue_push(queue, path);
            }
        }
    }
    closedir(dir);
}

void *search_worker(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    char path[MAX_PATH];
    
    while (1) {
        pthread_mutex_lock(data->active_mutex);
        if (queue_is_empty(data->queue) && *data->active_threads == 0) {
            pthread_mutex_unlock(data->active_mutex);
            break;
        }
        (*data->active_threads)++;
        pthread_mutex_unlock(data->active_mutex);
        
        if (queue_pop(data->queue, path)) {
            scan_directory(path, data->pattern, data->queue, 
                         data->results, data->result_count, 
                         data->result_mutex);
        }
        
        pthread_mutex_lock(data->active_mutex);
        (*data->active_threads)--;
        pthread_mutex_unlock(data->active_mutex);
    }
    
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <pattern> <directory>\n", argv[0]);
        return 1;
    }
    
    char *pattern = argv[1];
    char *root_dir = argv[2];
    
    FileInfo *results = malloc(MAX_RESULTS * sizeof(FileInfo));
    int result_count = 0;
    pthread_mutex_t result_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_t active_mutex = PTHREAD_MUTEX_INITIALIZER;
    int active_threads = 0;
    
    PathQueue *queue = queue_init();
    queue_push(queue, root_dir);
    
    ThreadData data = {
        .pattern = pattern,
        .queue = queue,
        .results = results,
        .result_count = &result_count,
        .result_mutex = &result_mutex,
        .active_threads = &active_threads,
        .active_mutex = &active_mutex
    };
    
    clock_t start = clock();
    
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, search_worker, &data);
    }
    
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    clock_t end = clock();
    
    for (int i = 0; i < result_count; i++) {
        printf("%s|%lu|%ld|%o\n", 
               results[i].path,
               results[i].size,
               results[i].mtime,
               results[i].mode);
    }
    
    fprintf(stderr, "âš¡ Found %d files in %.3f seconds\n", 
            result_count, 
            (double)(end - start) / CLOCKS_PER_SEC);
    
    free(results);
    free(queue);
    return 0;
}
CEOF
    
    if gcc -O3 -pthread -o "${C_HELPER}" "${c_source}" 2>/dev/null; then
        chmod +x "${C_HELPER}"
        echo -e "${GREEN}âœ“ Performance helper compiled${RESET}"
    else
        echo -e "${YELLOW}âš  Could not compile C helper${RESET}"
    fi
}

# Ultra-fast transfer engine with parallel streams
compile_transfer_engine() {
    local c_source="${VATHYS_BIN}/fasttransfer.c"
    
    cat > "${c_source}" << 'CEOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define CHUNK_SIZE (1024 * 1024 * 8)  // 8MB chunks
#define NUM_STREAMS 8

typedef struct {
    char *src_path;
    char *dst_path;
    off_t start_offset;
    off_t end_offset;
    int thread_id;
    unsigned long bytes_transferred;
} TransferThread;

void *transfer_chunk(void *arg) {
    TransferThread *t = (TransferThread *)arg;
    
    int src_fd = open(t->src_path, O_RDONLY);
    int dst_fd = open(t->dst_path, O_WRONLY | O_CREAT, 0644);
    
    if (src_fd < 0 || dst_fd < 0) {
        return NULL;
    }
    
    lseek(src_fd, t->start_offset, SEEK_SET);
    lseek(dst_fd, t->start_offset, SEEK_SET);
    
    char buffer[CHUNK_SIZE];
    off_t remaining = t->end_offset - t->start_offset;
    
    while (remaining > 0) {
        size_t to_read = (remaining < CHUNK_SIZE) ? remaining : CHUNK_SIZE;
        ssize_t bytes_read = read(src_fd, buffer, to_read);
        
        if (bytes_read <= 0) break;
        
        write(dst_fd, buffer, bytes_read);
        t->bytes_transferred += bytes_read;
        remaining -= bytes_read;
    }
    
    close(src_fd);
    close(dst_fd);
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }
    
    struct stat st;
    if (stat(argv[1], &st) != 0) {
        fprintf(stderr, "Cannot access source file\n");
        return 1;
    }
    
    off_t file_size = st.st_size;
    off_t chunk_size = file_size / NUM_STREAMS;
    
    pthread_t threads[NUM_STREAMS];
    TransferThread transfers[NUM_STREAMS];
    
    clock_t start = clock();
    
    for (int i = 0; i < NUM_STREAMS; i++) {
        transfers[i].src_path = argv[1];
        transfers[i].dst_path = argv[2];
        transfers[i].start_offset = i * chunk_size;
        transfers[i].end_offset = (i == NUM_STREAMS - 1) ? 
                                  file_size : (i + 1) * chunk_size;
        transfers[i].thread_id = i;
        transfers[i].bytes_transferred = 0;
        
        pthread_create(&threads[i], NULL, transfer_chunk, &transfers[i]);
    }
    
    for (int i = 0; i < NUM_STREAMS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    clock_t end = clock();
    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
    double speed_mbps = (file_size / (1024.0 * 1024.0)) / elapsed;
    
    printf("âœ“ Transferred %ld bytes in %.2f seconds (%.2f MB/s)\n", 
           file_size, elapsed, speed_mbps);
    
    return 0;
}
CEOF
    
    if gcc -O3 -pthread -o "${C_TRANSFER}" "${c_source}" 2>/dev/null; then
        chmod +x "${C_TRANSFER}"
        echo -e "${GREEN}âœ“ Transfer engine compiled${RESET}"
    else
        echo -e "${YELLOW}âš  Could not compile transfer engine${RESET}"
    fi
}

# SSH Connection Management
ssh_connect() {
    echo -e "\n${BOLD}${CYAN}ğŸ” SSH CONNECTION${RESET}"
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    
    echo -en "${YELLOW}Host/IP: ${RESET}"
    read SSH_HOST
    echo -en "${YELLOW}Username: ${RESET}"
    read SSH_USER
    echo -en "${YELLOW}Port [22]: ${RESET}"
    read port_input
    SSH_PORT="${port_input:-22}"
    
    echo -e "${CYAN}Testing connection...${RESET}"
    
    if ssh -o ConnectTimeout=5 -o BatchMode=yes -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "echo 'Connected'" 2>/dev/null; then
        SSH_CONNECTED=true
        echo -e "${GREEN}âœ“ Connected to ${SSH_USER}@${SSH_HOST}:${SSH_PORT}${RESET}"
        
        # Save session
        echo "${SSH_USER}@${SSH_HOST}:${SSH_PORT}" > "${SSH_SESSIONS}/last_session"
    else
        echo -e "${YELLOW}âš  Password required or key not configured${RESET}"
        echo -e "${CYAN}Attempting connection with password...${RESET}"
        
        if ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "echo 'Connected'" 2>/dev/null; then
            SSH_CONNECTED=true
            echo -e "${GREEN}âœ“ Connected${RESET}"
        else
            SSH_CONNECTED=false
            echo -e "${RED}âœ— Connection failed${RESET}"
            return 1
        fi
    fi
}

ssh_disconnect() {
    SSH_CONNECTED=false
    SSH_HOST=""
    SSH_USER=""
    SSH_PORT="22"
    echo -e "${GREEN}âœ“ Disconnected${RESET}"
}

# SSH File Operations
ssh_list_remote() {
    local remote_path="${1:-.}"
    
    if [[ "${SSH_CONNECTED}" != true ]]; then
        echo -e "${RED}âœ— Not connected to SSH server${RESET}"
        return 1
    fi
    
    echo -e "\n${BOLD}${CYAN}ğŸ“‚ Remote Directory: ${remote_path}${RESET}"
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    
    ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "ls -lh '${remote_path}'" 2>/dev/null
}

ssh_upload() {
    local local_file="$1"
    local remote_path="$2"
    
    if [[ "${SSH_CONNECTED}" != true ]]; then
        echo -e "${RED}âœ— Not connected${RESET}"
        return 1
    fi
    
    if [[ ! -f "${local_file}" ]]; then
        echo -e "${RED}âœ— Local file not found${RESET}"
        return 1
    fi
    
    echo -e "${CYAN}â¬†ï¸  Uploading: ${local_file} â†’ ${remote_path}${RESET}"
    
    if [[ -x "${C_TRANSFER}" ]]; then
        # Use ultra-fast parallel transfer via SSH
        local temp_script=$(mktemp)
        cat > "${temp_script}" << 'UPLOADEOF'
#!/bin/bash
scp -P "$1" -o Compression=yes -o "Ciphers=aes128-gcm@openssh.com" "$2" "$3@$4:$5"
UPLOADEOF
        chmod +x "${temp_script}"
        time "${temp_script}" "${SSH_PORT}" "${local_file}" "${SSH_USER}" "${SSH_HOST}" "${remote_path}"
        rm "${temp_script}"
    else
        scp -P "${SSH_PORT}" -C "${local_file}" "${SSH_USER}@${SSH_HOST}:${remote_path}"
    fi
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Upload complete${RESET}"
    else
        echo -e "${RED}âœ— Upload failed${RESET}"
        return 1
    fi
}

ssh_download() {
    local remote_file="$1"
    local local_path="$2"
    
    if [[ "${SSH_CONNECTED}" != true ]]; then
        echo -e "${RED}âœ— Not connected${RESET}"
        return 1
    fi
    
    echo -e "${CYAN}â¬‡ï¸  Downloading: ${remote_file} â†’ ${local_path}${RESET}"
    
    scp -P "${SSH_PORT}" -C "${SSH_USER}@${SSH_HOST}:${remote_file}" "${local_path}"
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Download complete${RESET}"
    else
        echo -e "${RED}âœ— Download failed${RESET}"
        return 1
    fi
}

ssh_delete_remote() {
    local remote_file="$1"
    
    if [[ "${SSH_CONNECTED}" != true ]]; then
        echo -e "${RED}âœ— Not connected${RESET}"
        return 1
    fi
    
    echo -e "${YELLOW}âš ï¸  Delete remote file: ${remote_file}?${RESET}"
    read -p "Type 'yes' to confirm: " confirm
    
    if [[ "${confirm}" == "yes" ]]; then
        ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "rm -rf '${remote_file}'"
        echo -e "${GREEN}âœ“ Deleted${RESET}"
    fi
}

ssh_rename_remote() {
    local old_name="$1"
    local new_name="$2"
    
    if [[ "${SSH_CONNECTED}" != true ]]; then
        echo -e "${RED}âœ— Not connected${RESET}"
        return 1
    fi
    
    ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "mv '${old_name}' '${new_name}'"
    echo -e "${GREEN}âœ“ Renamed${RESET}"
}

# Fast local search
fast_search() {
    local pattern="$1"
    local search_path="${2:-.}"
    
    echo -e "${CYAN}âš¡ Searching for: ${BOLD}${pattern}${RESET}"
    
    if [[ -x "${C_HELPER}" ]]; then
        "${C_HELPER}" "${pattern}" "${search_path}" 2>&1 | grep -v "Found"
    else
        find "${search_path}" -type f -iname "*${pattern}*" 2>/dev/null | while read -r file; do
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            local mtime=$(stat -f%m "$file" 2>/dev/null || stat -c%Y "$file" 2>/dev/null)
            local mode=$(stat -f%p "$file" 2>/dev/null || stat -c%a "$file" 2>/dev/null)
            echo "${file}|${size}|${mtime}|${mode}"
        done
    fi
}

# Display results
display_results() {
    local -a results=()
    local count=0
    
    while IFS='|' read -r path size mtime mode; do
        results+=("${path}|${size}|${mtime}|${mode}")
        ((count++))
    done
    
    if [[ ${count} -eq 0 ]]; then
        echo -e "${RED}âœ— No files found${RESET}"
        return 1
    fi
    
    echo -e "\n${BOLD}${GREEN}ğŸ¯ RESULTS (${count} files)${RESET}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    
    local idx=1
    for result in "${results[@]}"; do
        IFS='|' read -r path size mtime mode <<< "${result}"
        local filename=$(basename "${path}")
        local dirname=$(dirname "${path}")
        local hr_size=$(numfmt --to=iec-i --suffix=B "${size}" 2>/dev/null || echo "${size}B")
        
        echo -e "\n${BOLD}${WHITE}[${idx}]${RESET} ${CYAN}${filename}${RESET}"
        echo -e "    ${YELLOW}Size:${RESET} ${hr_size} â”‚ ${MAGENTA}Path:${RESET} ${dirname}"
        
        ((idx++))
        [[ ${idx} -gt 50 ]] && break  # Limit display
    done
    
    echo -e "\n${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
}

# Local file operations (existing functions remain the same)
file_copy() {
    local source="$1"
    local dest="$2"
    
    if [[ ! -f "${source}" ]]; then
        echo -e "${RED}âœ— Source not found${RESET}"
        return 1
    fi
    
    echo -e "${CYAN}ğŸ“‹ Copying...${RESET}"
    
    if [[ -x "${C_TRANSFER}" ]]; then
        "${C_TRANSFER}" "${source}" "${dest}"
    else
        cp -v "${source}" "${dest}"
    fi
}

file_move() {
    local source="$1"
    local dest="$2"
    
    echo -e "${CYAN}ğŸ“¦ Moving...${RESET}"
    mv -v "${source}" "${dest}" && echo -e "${GREEN}âœ“ Done${RESET}"
}

file_rename() {
    local source="$1"
    local new_name="$2"
    local dir=$(dirname "${source}")
    local dest="${dir}/${new_name}"
    
    echo -e "${CYAN}âœï¸  Renaming...${RESET}"
    mv -v "${source}" "${dest}" && echo -e "${GREEN}âœ“ Done${RESET}"
}

file_delete() {
    local target="$1"
    local force="$2"
    
    if [[ "${force}" != "force" ]]; then
        read -p "Delete ${target}? (yes/no): " confirm
        [[ "${confirm}" != "yes" ]] && return 1
    fi
    
    rm -rf "${target}" && echo -e "${GREEN}âœ“ Deleted${RESET}"
}

compress_files() {
    local output="$1"
    shift
    local files=("$@")
    
    echo -e "${CYAN}ğŸ“¦ Compressing...${RESET}"
    
    case "${output}" in
        *.tar.gz|*.tgz)
            tar -czf "${output}" "${files[@]}"
            ;;
        *.tar.xz|*.txz)
            tar -cJf "${output}" "${files[@]}"
            ;;
        *.zip)
            zip -9 -r "${output}" "${files[@]}"
            ;;
        *.7z)
            7z a -mx=9 "${output}" "${files[@]}"
            ;;
        *)
            echo -e "${RED}âœ— Unsupported format${RESET}"
            return 1
            ;;
    esac
    
    echo -e "${GREEN}âœ“ Created: ${output}${RESET}"
}

extract_archive() {
    local archive="$1"
    local dest="${2:-.}"
    
    echo -e "${CYAN}ğŸ“‚ Extracting...${RESET}"
    mkdir -p "${dest}"
    
    case "${archive}" in
        *.tar.gz|*.tgz) tar -xzf "${archive}" -C "${dest}" ;;
        *.tar.xz|*.txz) tar -xJf "${archive}" -C "${dest}" ;;
        *.zip) unzip -q "${archive}" -d "${dest}" ;;
        *.7z) 7z x "${archive}" -o"${dest}" ;;
        *.rar) unrar x "${archive}" "${dest}/" ;;
        *) echo -e "${RED}âœ— Unsupported${RESET}"; return 1 ;;
    esac
    
    echo -e "${GREEN}âœ“ Extracted${RESET}"
}

# Interactive menu
interactive_menu() {
    show_banner
    
    while true; do
        if [[ "${SSH_CONNECTED}" == true ]]; then
            echo -e "\n${GREEN}ğŸ”— SSH: ${SSH_USER}@${SSH_HOST}:${SSH_PORT}${RESET}"
        fi
        
        echo -e "\n${BOLD}${YELLOW}ğŸ¯ MAIN MENU${RESET}"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}1.${RESET}  ğŸ” Search Local Files"
        echo -e "${WHITE}2.${RESET}  ğŸ“‹ Copy Local Files"
        echo -e "${WHITE}3.${RESET}  ğŸ“¦ Move Local Files"
        echo -e "${WHITE}4.${RESET}  âœï¸  Rename Local Files"
        echo -e "${WHITE}5.${RESET}  ğŸ—‘ï¸  Delete Local Files"
        echo -e "${WHITE}6.${RESET}  ğŸ“¦ Compress Files"
        echo -e "${WHITE}7.${RESET}  ğŸ“‚ Extract Archive"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}8.${RESET}  ğŸ” SSH Connect"
        echo -e "${WHITE}9.${RESET}  ğŸ“‚ List Remote Directory"
        echo -e "${WHITE}10.${RESET} â¬†ï¸  Upload to SSH"
        echo -e "${WHITE}11.${RESET} â¬‡ï¸  Download from SSH"
        echo -e "${WHITE}12.${RESET} ğŸ—‘ï¸  Delete Remote File"
        echo -e "${WHITE}13.${RESET} âœï¸  Rename Remote File"
        echo -e "${WHITE}14.${RESET} ğŸ”Œ SSH Disconnect"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}0.${RESET}  ğŸšª Exit"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        
        echo -en "${MAGENTA}Select option: ${RESET}"
        read choice
        
        case "${choice}" in
            1) menu_search ;;
            2) menu_copy ;;
            3) menu_move ;;
            4) menu_rename ;;
            5) menu_delete ;;
            6) menu_compress ;;
            7) menu_extract ;;
            8) ssh_connect ;;
            9) menu_ssh_list ;;
            10) menu_ssh_upload ;;
            11) menu_ssh_download ;;
            12) menu_ssh_delete ;;
            13) menu_ssh_rename ;;
            14) ssh_disconnect ;;
            0) echo -e "${GREEN}ğŸ‘‹ Goodbye!${RESET}"; exit 0 ;;
            *) echo -e "${RED}âœ— Invalid option${RESET}" ;;
        esac
    done
}

# Menu functions
menu_search() {
    echo -en "${CYAN}Search pattern: ${RESET}"
    read pattern
    echo -en "${CYAN}Path [.]: ${RESET}"
    read path
    path="${path:-.}"
    
    fast_search "${pattern}" "${path}" | display_results
    
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_copy() {
    echo -en "${CYAN}Source: ${RESET}"
    read source
    echo -en "${CYAN}Destination: ${RESET}"
    read dest
    file_copy "${source}" "${dest}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_move() {
    echo -en "${CYAN}Source: ${RESET}"
    read source
    echo -en "${CYAN}Destination: ${RESET}"
    read dest
    file_move "${source}" "${dest}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_rename() {
    echo -en "${CYAN}File: ${RESET}"
    read source
    echo -en "${CYAN}New name: ${RESET}"
    read newname
    file_rename "${source}" "${newname}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_delete() {
    echo -en "${CYAN}Target: ${RESET}"
    read target
    file_delete "${target}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_compress() {
    echo -en "${CYAN}Output archive: ${RESET}"
    read output
    echo -en "${CYAN}Files (space-separated): ${RESET}"
    read files
    compress_files "${output}" ${files}
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_extract() {
    echo -en "${CYAN}Archive: ${RESET}"
    read archive
    echo -en "${CYAN}Destination [.]: ${RESET}"
    read dest
    dest="${dest:-.}"
    extract_archive "${archive}" "${dest}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_ssh_list() {
    echo -en "${CYAN}Remote path [.]: ${RESET}"
    read path
    path="${path:-.}"
    ssh_list_remote "${path}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_ssh_upload() {
    echo -en "${CYAN}Local file: ${RESET}"
    read local_file
    echo -en "${CYAN}Remote path: ${RESET}"
    read remote_path
    ssh_upload "${local_file}" "${remote_path}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_ssh_download() {
    echo -en "${CYAN}Remote file: ${RESET}"
    read remote_file
    echo -en "${CYAN}Local path [.]: ${RESET}"
    read local_path
    local_path="${local_path:-.}"
    ssh_download "${remote_file}" "${local_path}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_ssh_delete() {
    echo -en "${CYAN}Remote file: ${RESET}"
    read remote_file
    ssh_delete_remote "${remote_file}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

menu_ssh_rename() {
    echo -en "${CYAN}Remote file: ${RESET}"
    read old_name
    echo -en "${CYAN}New name: ${RESET}"
    read new_name
    ssh_rename_remote "${old_name}" "${new_name}"
    echo -en "${YELLOW}Press Enter...${RESET}"
    read
}

# CLI interface
parse_cli() {
    case "$1" in
        search|-s)
            shift
            fast_search "$@" | display_results
            ;;
        copy|-c)
            file_copy "$2" "$3"
            ;;
        move|-m)
            file_move "$2" "$3"
            ;;
        rename|-r)
            file_rename "$2" "$3"
            ;;
        delete|-d)
            file_delete "$2" "$3"
            ;;
        compress|-z)
            shift
            compress_files "$@"
            ;;
        extract|-x)
            extract_archive "$2" "$3"
            ;;
        ssh-connect)
            ssh_connect
            ;;
        ssh-upload)
            ssh_upload "$2" "$3"
            ;;
        ssh-download)
            ssh_download "$2" "$3"
            ;;
        ssh-list)
            ssh_list_remote "$2"
            ;;
        ssh-delete)
            ssh_delete_remote "$2"
            ;;
        ssh-rename)
            ssh_rename_remote "$2" "$3"
            ;;
        interactive|-i)
            interactive_menu
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            interactive_menu
            ;;
    esac
}

show_help() {
    show_banner
    cat << EOF
${BOLD}${YELLOW}USAGE:${RESET}
  vath [COMMAND] [OPTIONS]

${BOLD}${YELLOW}LOCAL COMMANDS:${RESET}
  ${CYAN}search${RESET}, -s          Search files
  ${CYAN}copy${RESET}, -c            Copy files (ultra-fast)
  ${CYAN}move${RESET}, -m            Move files
  ${CYAN}rename${RESET}, -r          Rename files
  ${CYAN}delete${RESET}, -d          Delete files/directories
  ${CYAN}compress${RESET}, -z        Compress files
  ${CYAN}extract${RESET}, -x         Extract archives

${BOLD}${YELLOW}SSH/SFTP COMMANDS:${RESET}
  ${CYAN}ssh-connect${RESET}         Connect to SSH server
  ${CYAN}ssh-upload${RESET}          Upload file to remote
  ${CYAN}ssh-download${RESET}        Download from remote
  ${CYAN}ssh-list${RESET}            List remote directory
  ${CYAN}ssh-delete${RESET}          Delete remote file
  ${CYAN}ssh-rename${RESET}          Rename remote file

${BOLD}${YELLOW}EXAMPLES:${RESET}
  ${GREEN}# Local operations${RESET}
  vath search vacation /home
  vath copy largefile.iso /backup
  vath compress data.tar.xz ./files

  ${GREEN}# SSH operations${RESET}
  vath ssh-connect
  vath ssh-upload local.tar remote/path/
  vath ssh-download remote/file.zip ./
  vath ssh-list /var/www
  
  ${GREEN}# Interactive mode${RESET}
  vath -i

${BOLD}${YELLOW}FEATURES:${RESET}
  â€¢ Multi-threaded search (16 threads)
  â€¢ Parallel file transfers (8 streams)
  â€¢ SSH/SFTP with compression
  â€¢ Maximum compression algorithms
  â€¢ Real-time progress tracking
  â€¢ Unlimited transfer speeds

${BOLD}${YELLOW}SUPPORTED FORMATS:${RESET}
  Compression: tar.gz, tar.xz, zip, 7z
  Extraction:  All above + rar, tar, gz, bz2

EOF
}

# Main
main() {
    init_vathys
    
    if [[ $# -eq 0 ]]; then
        interactive_menu
    else
        parse_cli "$@"
    fi
}

main "$@"
