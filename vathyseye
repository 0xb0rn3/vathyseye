#!/usr/bin/env bash

#############################################################################
# VathysEye 5.1 - Ultimate CLI File Manager with SSH/SFTP
# Author: 0xb0rn3 | 0xbv1
# Description: Lightning-fast file manager with mass copy, exclusions & auto-update
#############################################################################

VERSION="5.1.0"
AUTHOR="0xb0rn3 | 0xbv1"
UPDATE_URL="https://raw.githubusercontent.com/0xb0rn3/vathyseye/main/vathyseye"
UPDATE_CHECK_URL="https://api.github.com/repos/0xb0rn3/vathyseye/releases/latest"

# Color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[0;37m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Configuration
VATHYS_DIR="${HOME}/.vathyseye"
VATHYS_BIN="${VATHYS_DIR}/bin"
VATHYS_CACHE="${VATHYS_DIR}/cache"
VATHYS_CONFIG="${VATHYS_DIR}/config"
SSH_SESSIONS="${VATHYS_DIR}/sessions"
C_HELPER="${VATHYS_BIN}/fileops"
C_TRANSFER="${VATHYS_BIN}/fasttransfer"
INDEX_DB="${VATHYS_CACHE}/file.index"

# SSH Session variables
SSH_HOST=""
SSH_USER=""
SSH_PORT="22"
SSH_CONNECTED=false

# Banner
show_banner() {
    clear
    cat << "EOF"
â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•    â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•  
 â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â•šâ•â•â•â•  â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
                                                                              
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  ğŸ”¥ ULTIMATE CLI FILE MANAGER 5.1 ğŸ”¥                            â”‚
        â”‚  âš¡ LOCAL â€¢ SSH â€¢ SFTP â€¢ MASS COPY â€¢ EXCLUDE â€¢ AUTO-UPDATE âš¡   â”‚
        â”‚  Author: 0xb0rn3 | 0xbv1  â”‚  IG: theehiv3  â”‚  Version: 5.1     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EOF
}

# Initialize directories
init_vathys() {
    mkdir -p "${VATHYS_DIR}" "${VATHYS_BIN}" "${VATHYS_CACHE}" "${VATHYS_CONFIG}" "${SSH_SESSIONS}"
    
    # Check if C helpers exist, compile if needed
    if [[ ! -x "${C_HELPER}" ]]; then
        echo -e "${YELLOW}âš¡ Compiling performance helper...${RESET}"
        compile_c_helper
    fi
    
    if [[ ! -x "${C_TRANSFER}" ]]; then
        echo -e "${YELLOW}âš¡ Compiling ultra-fast transfer engine...${RESET}"
        compile_transfer_engine
    fi
}

# Enhanced C helper with optimized multi-threading
compile_c_helper() {
    local c_source="${VATHYS_BIN}/fileops.c"
    
    cat > "${c_source}" << 'CEOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fnmatch.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>

#define MAX_PATH 4096
#define MAX_RESULTS 100000
#define NUM_THREADS 16
#define QUEUE_SIZE 10000

typedef struct {
    char path[MAX_PATH];
    unsigned long size;
    time_t mtime;
    mode_t mode;
} FileInfo;

typedef struct {
    char paths[QUEUE_SIZE][MAX_PATH];
    int front;
    int rear;
    int count;
    pthread_mutex_t mutex;
    pthread_cond_t not_empty;
    pthread_cond_t not_full;
} PathQueue;

typedef struct {
    char *pattern;
    PathQueue *queue;
    FileInfo *results;
    int *result_count;
    pthread_mutex_t *result_mutex;
    int *active_threads;
    pthread_mutex_t *active_mutex;
} ThreadData;

PathQueue* queue_init() {
    PathQueue *q = malloc(sizeof(PathQueue));
    q->front = 0;
    q->rear = 0;
    q->count = 0;
    pthread_mutex_init(&q->mutex, NULL);
    pthread_cond_init(&q->not_empty, NULL);
    pthread_cond_init(&q->not_full, NULL);
    return q;
}

void queue_push(PathQueue *q, const char *path) {
    pthread_mutex_lock(&q->mutex);
    while (q->count >= QUEUE_SIZE) {
        pthread_cond_wait(&q->not_full, &q->mutex);
    }
    strncpy(q->paths[q->rear], path, MAX_PATH);
    q->rear = (q->rear + 1) % QUEUE_SIZE;
    q->count++;
    pthread_cond_signal(&q->not_empty);
    pthread_mutex_unlock(&q->mutex);
}

int queue_pop(PathQueue *q, char *path) {
    pthread_mutex_lock(&q->mutex);
    while (q->count == 0) {
        pthread_cond_wait(&q->not_empty, &q->mutex);
    }
    strncpy(path, q->paths[q->front], MAX_PATH);
    q->front = (q->front + 1) % QUEUE_SIZE;
    q->count--;
    pthread_cond_signal(&q->not_full);
    pthread_mutex_unlock(&q->mutex);
    return 1;
}

int queue_is_empty(PathQueue *q) {
    pthread_mutex_lock(&q->mutex);
    int empty = (q->count == 0);
    pthread_mutex_unlock(&q->mutex);
    return empty;
}

int matches_pattern(const char *filename, const char *pattern) {
    if (strcmp(pattern, "*") == 0) return 1;
    return fnmatch(pattern, filename, FNM_CASEFOLD) == 0 ||
           strcasestr(filename, pattern) != NULL;
}

void scan_directory(const char *dir_path, const char *pattern, 
                   PathQueue *queue, FileInfo *results, 
                   int *result_count, pthread_mutex_t *mutex) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;
    
    struct dirent *entry;
    struct stat st;
    char path[MAX_PATH];
    
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;
            
        snprintf(path, sizeof(path), "%s/%s", dir_path, entry->d_name);
        
        if (stat(path, &st) == 0) {
            if (S_ISREG(st.st_mode) && matches_pattern(entry->d_name, pattern)) {
                pthread_mutex_lock(mutex);
                if (*result_count < MAX_RESULTS) {
                    strncpy(results[*result_count].path, path, MAX_PATH);
                    results[*result_count].size = st.st_size;
                    results[*result_count].mtime = st.st_mtime;
                    results[*result_count].mode = st.st_mode;
                    (*result_count)++;
                }
                pthread_mutex_unlock(mutex);
            }
            
            if (S_ISDIR(st.st_mode)) {
                queue_push(queue, path);
            }
        }
    }
    closedir(dir);
}

void *search_worker(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    char path[MAX_PATH];
    
    while (1) {
        pthread_mutex_lock(data->active_mutex);
        if (queue_is_empty(data->queue) && *data->active_threads == 0) {
            pthread_mutex_unlock(data->active_mutex);
            break;
        }
        (*data->active_threads)++;
        pthread_mutex_unlock(data->active_mutex);
        
        if (queue_pop(data->queue, path)) {
            scan_directory(path, data->pattern, data->queue, 
                         data->results, data->result_count, 
                         data->result_mutex);
        }
        
        pthread_mutex_lock(data->active_mutex);
        (*data->active_threads)--;
        pthread_mutex_unlock(data->active_mutex);
    }
    
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <pattern> <directory>\n", argv[0]);
        return 1;
    }
    
    char *pattern = argv[1];
    char *root_dir = argv[2];
    
    FileInfo *results = malloc(MAX_RESULTS * sizeof(FileInfo));
    int result_count = 0;
    pthread_mutex_t result_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_t active_mutex = PTHREAD_MUTEX_INITIALIZER;
    int active_threads = 0;
    
    PathQueue *queue = queue_init();
    queue_push(queue, root_dir);
    
    ThreadData data = {
        .pattern = pattern,
        .queue = queue,
        .results = results,
        .result_count = &result_count,
        .result_mutex = &result_mutex,
        .active_threads = &active_threads,
        .active_mutex = &active_mutex
    };
    
    clock_t start = clock();
    
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, search_worker, &data);
    }
    
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    clock_t end = clock();
    
    for (int i = 0; i < result_count; i++) {
        printf("%s|%lu|%ld|%o\n", 
               results[i].path,
               results[i].size,
               results[i].mtime,
               results[i].mode);
    }
    
    fprintf(stderr, "âš¡ Found %d files in %.3f seconds\n", 
            result_count, 
            (double)(end - start) / CLOCKS_PER_SEC);
    
    free(results);
    free(queue);
    return 0;
}
CEOF
    
    if gcc -O3 -pthread -o "${C_HELPER}" "${c_source}" 2>/dev/null; then
        chmod +x "${C_HELPER}"
        echo -e "${GREEN}âœ“ Performance helper compiled${RESET}"
    else
        echo -e "${YELLOW}âš  Could not compile C helper${RESET}"
    fi
}

# Ultra-fast transfer engine with parallel streams
compile_transfer_engine() {
    local c_source="${VATHYS_BIN}/fasttransfer.c"
    
    cat > "${c_source}" << 'CEOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define CHUNK_SIZE (1024 * 1024 * 8)
#define NUM_STREAMS 8

typedef struct {
    char *src_path;
    char *dst_path;
    off_t start_offset;
    off_t end_offset;
    int thread_id;
    unsigned long bytes_transferred;
} TransferThread;

void *transfer_chunk(void *arg) {
    TransferThread *t = (TransferThread *)arg;
    
    int src_fd = open(t->src_path, O_RDONLY);
    int dst_fd = open(t->dst_path, O_WRONLY | O_CREAT, 0644);
    
    if (src_fd < 0 || dst_fd < 0) {
        return NULL;
    }
    
    lseek(src_fd, t->start_offset, SEEK_SET);
    lseek(dst_fd, t->start_offset, SEEK_SET);
    
    char buffer[CHUNK_SIZE];
    off_t remaining = t->end_offset - t->start_offset;
    
    while (remaining > 0) {
        size_t to_read = (remaining < CHUNK_SIZE) ? remaining : CHUNK_SIZE;
        ssize_t bytes_read = read(src_fd, buffer, to_read);
        
        if (bytes_read <= 0) break;
        
        write(dst_fd, buffer, bytes_read);
        t->bytes_transferred += bytes_read;
        remaining -= bytes_read;
    }
    
    close(src_fd);
    close(dst_fd);
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }
    
    struct stat st;
    if (stat(argv[1], &st) != 0) {
        fprintf(stderr, "Cannot access source file\n");
        return 1;
    }
    
    off_t file_size = st.st_size;
    off_t chunk_size = file_size / NUM_STREAMS;
    
    pthread_t threads[NUM_STREAMS];
    TransferThread transfers[NUM_STREAMS];
    
    clock_t start = clock();
    
    for (int i = 0; i < NUM_STREAMS; i++) {
        transfers[i].src_path = argv[1];
        transfers[i].dst_path = argv[2];
        transfers[i].start_offset = i * chunk_size;
        transfers[i].end_offset = (i == NUM_STREAMS - 1) ? 
                                  file_size : (i + 1) * chunk_size;
        transfers[i].thread_id = i;
        transfers[i].bytes_transferred = 0;
        
        pthread_create(&threads[i], NULL, transfer_chunk, &transfers[i]);
    }
    
    for (int i = 0; i < NUM_STREAMS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    clock_t end = clock();
    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
    double speed_mbps = (file_size / (1024.0 * 1024.0)) / elapsed;
    
    printf("âœ“ Transferred %ld bytes in %.2f seconds (%.2f MB/s)\n", 
           file_size, elapsed, speed_mbps);
    
    return 0;
}
CEOF
    
    if gcc -O3 -pthread -o "${C_TRANSFER}" "${c_source}" 2>/dev/null; then
        chmod +x "${C_TRANSFER}"
        echo -e "${GREEN}âœ“ Transfer engine compiled${RESET}"
    else
        echo -e "${YELLOW}âš  Could not compile transfer engine${RESET}"
    fi
}

# ============================================================================
# NEW FEATURE: MASS COPY WITH EXCLUSIONS
# ============================================================================

mass_copy() {
    local source_dir="$1"
    local dest_dir="$2"
    shift 2
    local exclude_list=("$@")
    
    if [[ ! -d "${source_dir}" ]]; then
        echo -e "${RED}âœ— Source directory not found: ${source_dir}${RESET}"
        return 1
    fi
    
    echo -e "\n${BOLD}${CYAN}ğŸ“¦ MASS COPY WITH EXCLUSIONS${RESET}"
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    echo -e "${YELLOW}Source:${RESET} ${source_dir}"
    echo -e "${YELLOW}Destination:${RESET} ${dest_dir}"
    
    if [[ ${#exclude_list[@]} -gt 0 ]]; then
        echo -e "${YELLOW}Excluding:${RESET}"
        for item in "${exclude_list[@]}"; do
            echo -e "  ${RED}âœ—${RESET} ${item}"
        done
    fi
    
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}\n"
    
    # Create destination directory
    mkdir -p "${dest_dir}"
    
    # Build rsync exclude arguments
    local rsync_excludes=""
    for item in "${exclude_list[@]}"; do
        rsync_excludes="${rsync_excludes} --exclude='${item}'"
    done
    
    # Check if rsync is available for optimal performance
    if command -v rsync >/dev/null 2>&1; then
        echo -e "${CYAN}âš¡ Using optimized rsync transfer...${RESET}\n"
        
        local rsync_cmd="rsync -avh --progress ${rsync_excludes} \"${source_dir}/\" \"${dest_dir}/\""
        
        eval "${rsync_cmd}"
        
        if [[ $? -eq 0 ]]; then
            echo -e "\n${GREEN}âœ“ Mass copy completed successfully${RESET}"
            
            # Show statistics
            local total_size=$(du -sh "${dest_dir}" 2>/dev/null | cut -f1)
            local file_count=$(find "${dest_dir}" -type f 2>/dev/null | wc -l)
            
            echo -e "${CYAN}ğŸ“Š Statistics:${RESET}"
            echo -e "  ${YELLOW}Total Size:${RESET} ${total_size}"
            echo -e "  ${YELLOW}Files:${RESET} ${file_count}"
        else
            echo -e "${RED}âœ— Mass copy failed${RESET}"
            return 1
        fi
    else
        # Fallback to manual copy with exclusions
        echo -e "${YELLOW}âš  rsync not found, using fallback method...${RESET}\n"
        
        local copied=0
        local skipped=0
        
        cd "${source_dir}" || return 1
        
        while IFS= read -r -d '' file; do
            local relative_path="${file#./}"
            local should_exclude=false
            
            # Check if file matches any exclusion pattern
            for pattern in "${exclude_list[@]}"; do
                if [[ "${relative_path}" == ${pattern}* ]] || [[ "${relative_path}" == *"${pattern}"* ]]; then
                    should_exclude=true
                    ((skipped++))
                    break
                fi
            done
            
            if [[ "${should_exclude}" == false ]]; then
                local dest_file="${dest_dir}/${relative_path}"
                local dest_file_dir=$(dirname "${dest_file}")
                
                mkdir -p "${dest_file_dir}"
                
                if [[ -x "${C_TRANSFER}" ]]; then
                    "${C_TRANSFER}" "${file}" "${dest_file}" 2>/dev/null
                else
                    cp -a "${file}" "${dest_file}"
                fi
                
                ((copied++))
                
                if [[ $((copied % 10)) -eq 0 ]]; then
                    echo -ne "\r${CYAN}Progress: ${copied} files copied, ${skipped} skipped${RESET}"
                fi
            fi
        done < <(find . -type f -print0)
        
        echo -e "\n${GREEN}âœ“ Mass copy completed${RESET}"
        echo -e "${CYAN}ğŸ“Š Statistics:${RESET}"
        echo -e "  ${GREEN}Copied:${RESET} ${copied} files"
        echo -e "  ${YELLOW}Skipped:${RESET} ${skipped} files"
    fi
}

# Enhanced mass copy with interactive selection
interactive_mass_copy() {
    echo -e "\n${BOLD}${CYAN}ğŸ“¦ MASS COPY WITH EXCLUSIONS${RESET}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
    
    echo -en "${YELLOW}Source directory: ${RESET}"
    read source_dir
    
    if [[ ! -d "${source_dir}" ]]; then
        echo -e "${RED}âœ— Directory not found${RESET}"
        return 1
    fi
    
    echo -en "${YELLOW}Destination directory: ${RESET}"
    read dest_dir
    
    # Show directory contents
    echo -e "\n${CYAN}ğŸ“‚ Contents of ${source_dir}:${RESET}"
    local idx=1
    declare -A dir_map
    
    while IFS= read -r item; do
        local basename=$(basename "${item}")
        echo -e "  ${WHITE}[${idx}]${RESET} ${basename}"
        dir_map[${idx}]="${basename}"
        ((idx++))
    done < <(find "${source_dir}" -maxdepth 1 -mindepth 1 | sort)
    
    echo -e "\n${YELLOW}Exclude items (comma-separated numbers, or 'none'):${RESET}"
    echo -en "${CYAN}Selection: ${RESET}"
    read exclusion_input
    
    local exclude_list=()
    
    if [[ "${exclusion_input}" != "none" && -n "${exclusion_input}" ]]; then
        IFS=',' read -ra selections <<< "${exclusion_input}"
        
        for sel in "${selections[@]}"; do
            sel=$(echo "${sel}" | xargs)  # Trim whitespace
            if [[ -n "${dir_map[${sel}]}" ]]; then
                exclude_list+=("${dir_map[${sel}]}")
            fi
        done
    fi
    
    echo -e "\n${CYAN}Confirm operation:${RESET}"
    echo -e "  ${YELLOW}Source:${RESET} ${source_dir}"
    echo -e "  ${YELLOW}Destination:${RESET} ${dest_dir}"
    
    if [[ ${#exclude_list[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}Excluding:${RESET} ${exclude_list[*]}"
    else
        echo -e "  ${YELLOW}Excluding:${RESET} nothing"
    fi
    
    echo -en "\n${MAGENTA}Proceed? (yes/no): ${RESET}"
    read confirm
    
    if [[ "${confirm}" == "yes" ]]; then
        mass_copy "${source_dir}" "${dest_dir}" "${exclude_list[@]}"
    else
        echo -e "${YELLOW}âš  Operation cancelled${RESET}"
    fi
}

# ============================================================================
# NEW FEATURE: AUTO-UPDATE SYSTEM
# ============================================================================

check_for_updates() {
    local silent_mode="${1:-false}"
    
    if [[ "${silent_mode}" != "true" ]]; then
        echo -e "\n${BOLD}${CYAN}ğŸ”„ CHECKING FOR UPDATES${RESET}"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}\n"
    fi
    
    # Check if we have internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
        if [[ "${silent_mode}" != "true" ]]; then
            echo -e "${YELLOW}âš  No internet connection${RESET}"
        fi
        return 1
    fi
    
    # Try to get latest version from GitHub API
    local latest_version=""
    
    if command -v curl >/dev/null 2>&1; then
        latest_version=$(curl -s "${UPDATE_CHECK_URL}" 2>/dev/null | grep -o '"tag_name": *"[^"]*"' | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' | head -n1)
    elif command -v wget >/dev/null 2>&1; then
        latest_version=$(wget -qO- "${UPDATE_CHECK_URL}" 2>/dev/null | grep -o '"tag_name": *"[^"]*"' | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' | head -n1)
    else
        if [[ "${silent_mode}" != "true" ]]; then
            echo -e "${YELLOW}âš  curl or wget required for update check${RESET}"
        fi
        return 1
    fi
    
    if [[ -z "${latest_version}" ]]; then
        latest_version="${VERSION}"
    fi
    
    echo -e "${CYAN}Current version:${RESET} ${VERSION}"
    echo -e "${CYAN}Latest version:${RESET}  ${latest_version}"
    
    # Compare versions
    if [[ "${VERSION}" == "${latest_version}" ]]; then
        echo -e "${GREEN}âœ“ You're running the latest version${RESET}"
        return 0
    else
        echo -e "${YELLOW}âš¡ Update available: ${latest_version}${RESET}"
        return 2
    fi
}

perform_update() {
    echo -e "\n${BOLD}${CYAN}ğŸ”„ AUTO-UPDATE SYSTEM${RESET}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
    
    check_for_updates
    local check_result=$?
    
    if [[ ${check_result} -eq 0 ]]; then
        return 0
    elif [[ ${check_result} -eq 1 ]]; then
        return 1
    fi
    
    echo -en "\n${MAGENTA}Download and install update? (yes/no): ${RESET}"
    read confirm
    
    if [[ "${confirm}" != "yes" ]]; then
        echo -e "${YELLOW}âš  Update cancelled${RESET}"
        return 1
    fi
    
    echo -e "\n${CYAN}ğŸ“¥ Downloading update...${RESET}"
    
    local temp_file=$(mktemp)
    local script_path=$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")
    
    if command -v curl >/dev/null 2>&1; then
        curl -L -o "${temp_file}" "${UPDATE_URL}" 2>/dev/null
    elif command -v wget >/dev/null 2>&1; then
        wget -O "${temp_file}" "${UPDATE_URL}" 2>/dev/null
    else
        echo -e "${RED}âœ— Download failed (curl/wget not found)${RESET}"
        rm -f "${temp_file}"
        return 1
    fi
    
    if [[ ! -s "${temp_file}" ]]; then
        echo -e "${RED}âœ— Download failed (empty file)${RESET}"
        rm -f "${temp_file}"
        return 1
    fi
    
    # Backup current version
    local backup_file="${script_path}.backup"
    cp "${script_path}" "${backup_file}"
    
    echo -e "${CYAN}ğŸ’¾ Installing update...${RESET}"
    
    # Install update
    chmod +x "${temp_file}"
    
    if cp "${temp_file}" "${script_path}"; then
        rm -f "${temp_file}"
        echo -e "${GREEN}âœ“ Update installed successfully${RESET}"
        echo -e "${CYAN}Backup saved: ${backup_file}${RESET}"
        echo -e "\n${YELLOW}âš¡ Restarting VathysEye...${RESET}\n"
        sleep 2
        exec "${script_path}" "$@"
    else
        echo -e "${RED}âœ— Installation failed${RESET}"
        echo -e "${CYAN}Restoring backup...${RESET}"
        cp "${backup_file}" "${script_path}"
        rm -f "${temp_file}"
        return 1
    fi
}

# ============================================================================
# SSH CONNECTION MANAGEMENT
# ============================================================================

ssh_connect() {
    echo -e "\n${BOLD}${CYAN}ğŸ” SSH CONNECTION${RESET}"
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    
    echo -en "${YELLOW}Host/IP: ${RESET}"
    read SSH_HOST
    echo -en "${YELLOW}Username: ${RESET}"
    read SSH_USER
    echo -en "${YELLOW}Port [22]: ${RESET}"
    read port_input
    SSH_PORT="${port_input:-22}"
    
    echo -e "${CYAN}Testing connection...${RESET}"
    
    if ssh -o ConnectTimeout=5 -o BatchMode=yes -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "echo 'Connected'" 2>/dev/null; then
        SSH_CONNECTED=true
        echo -e "${GREEN}âœ“ Connected to ${SSH_USER}@${SSH_HOST}:${SSH_PORT}${RESET}"
        echo "${SSH_USER}@${SSH_HOST}:${SSH_PORT}" > "${SSH_SESSIONS}/last_session"
    else
        echo -e "${YELLOW}âš  Password required or key not configured${RESET}"
        if ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "echo 'Connected'" 2>/dev/null; then
            SSH_CONNECTED=true
            echo -e "${GREEN}âœ“ Connected${RESET}"
        else
            SSH_CONNECTED=false
            echo -e "${RED}âœ— Connection failed${RESET}"
            return 1
        fi
    fi
}

# Remaining SSH functions and main menu system
interactive_menu() {
    show_banner
    
    while true; do
        if [[ "${SSH_CONNECTED}" == true ]]; then
            echo -e "\n${GREEN}ğŸ”— SSH: ${SSH_USER}@${SSH_HOST}:${SSH_PORT}${RESET}"
        fi
        
        echo -e "\n${BOLD}${YELLOW}ğŸ¯ MAIN MENU${RESET}"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}1.${RESET}  ğŸ” Search Local Files"
        echo -e "${WHITE}2.${RESET}  ğŸ“‹ Copy Local Files"
        echo -e "${WHITE}3.${RESET}  ğŸ“¦ Mass Copy with Exclude"
        echo -e "${WHITE}4.${RESET}  âœï¸ Rename Local Files"
        echo -e "${WHITE}5.${RESET}  ğŸ—‘ï¸ Delete Local Files"
        echo -e "${WHITE}6.${RESET}  ğŸ“¦ Compress Files"
        echo -e "${WHITE}7.${RESET}  ğŸ“‚ Extract Archive"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}8.${RESET}  ğŸ” SSH Connect"
        echo -e "${WHITE}9.${RESET}  ğŸ“‚ List Remote Directory"
        echo -e "${WHITE}10.${RESET} â¬†ï¸ Upload to SSH"
        echo -e "${WHITE}11.${RESET} â¬‡ï¸ Download from SSH"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo -e "${WHITE}12.${RESET} ğŸ”„ Check for Updates"
        echo -e "${WHITE}0.${RESET}  ğŸšª Exit"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        
        echo -en "${MAGENTA}Select option: ${RESET}"
        read choice
        
        case "${choice}" in
            1) echo "Search feature" ;;
            2) echo "Copy feature" ;;
            3) interactive_mass_copy ;;
            4) echo "Rename feature" ;;
            5) echo "Delete feature" ;;
            6) echo "Compress feature" ;;
            7) echo "Extract feature" ;;
            8) ssh_connect ;;
            9) echo "SSH list" ;;
            10) echo "SSH upload" ;;
            11) echo "SSH download" ;;
            12) perform_update ;;
            0) echo -e "${GREEN}ğŸ‘‹ Goodbye!${RESET}"; exit 0 ;;
            *) echo -e "${RED}âœ— Invalid option${RESET}" ;;
        esac
    done
}

# Parse CLI arguments
parse_cli() {
    case "$1" in
        mass-copy|mc)
            shift
            if [[ $# -lt 2 ]]; then
                echo -e "${YELLOW}Usage: vath mass-copy <source> <dest> [exclude1] [exclude2] ...${RESET}"
                return 1
            fi
            local src="$1"
            local dst="$2"
            shift 2
            mass_copy "${src}" "${dst}" "$@"
            ;;
        update)
            perform_update
            ;;
        check-update)
            check_for_updates
            ;;
        interactive|-i)
            interactive_menu
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            interactive_menu
            ;;
    esac
}

show_help() {
    show_banner
    cat << EOF
${BOLD}${YELLOW}USAGE:${RESET}
  vath [COMMAND] [OPTIONS]

${BOLD}${YELLOW}NEW COMMANDS (v5.1):${RESET}
  ${CYAN}mass-copy, mc${RESET}      Mass copy with exclusions
  ${CYAN}update${RESET}             Auto-update to latest version
  ${CYAN}check-update${RESET}       Check for available updates

${BOLD}${YELLOW}EXAMPLES:${RESET}
  ${GREEN}# Mass copy excluding specific folders${RESET}
  vath mass-copy /source /destination UNCOMPLETED temp cache

  ${GREEN}# Check and install updates${RESET}
  vath update
  
  ${GREEN}# Just check for updates${RESET}
  vath check-update

EOF
}

# Main entry point
main() {
    init_vathys
    
    if [[ $# -eq 0 ]]; then
        interactive_menu
    else
        parse_cli "$@"
    fi
}

main "$@"
